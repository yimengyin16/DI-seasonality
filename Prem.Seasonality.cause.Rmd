---
title: "Exploring possible causes of seasonality in DI applications"
output:
  pdf_document:
    includes:
      in_header: LatexPreamble.sty
    number_sections: yes
editor_options: 
  chunk_output_type: console
---

```{r preamble, include=FALSE}

library(plyr)
library(ggplot2)
library(scales)
library(xtable)
#library(DataCombine) # it loads dplyr!
library(magrittr)
library("tidyr")
library("knitr")
library(lubridate)
library(tsibble)
library(fable)
library(feasts)
library(dplyr)
library(purrr)
library(grid)
library(gridExtra)
library(magrittr)

options(xtable.include.rownames = F,
        xtable.booktabs = T,
        xtable.caption.placement = "top")

source("General.R")
select <- dplyr::select

plot.path = "paper_plot/"
dir.fig_newVer = "paper_plot/fig_newVer/"


##' This analysis depends on the following inputs
# 
#'   1. Data/itermed_ets.rds (generated by Seasonality.Pattern.Rmd - modeling seasonality)
#'        - A list containing the following elements
#           - Panel_all: Panel data up to the most recent date
#'          - Panel:     Panel data up to Feb 2020
#'          - mod_ets:   ets model results for all variables of interest
#'          - df_comp_ets: decomposed time series extracted from mod_ets
#
#'   2. Data/emplyIndustry.RData (generated by Data.import.BEA.R)
#'        - df_emplyInd: annual employment data by industry and state
#'          (no national, need to generate in this script)
#
#'   3. Data/temperature.RData (generated by Data.import.temperature.R)
#'        - df_temperature: monthly average temperature (F) by state 
#'          (national for contiguous 48 states)


ls_ets <- readRDS("Data/intermed_ets.rds")
(load("Data/emplyIndustry.RData")) # df_emplyInd
(load("Data/temperature.RData"))   # df_temperature   


```


## Preparing temperature and employment structure data for regression
```{r include=FALSE}

# Prep 1: temperature 
#   - calculate average monthly temperature from 2000-2020
#   - output: 49 states excluding Hawaii, and national (48 contiguous states)

df_temp_monAvg <- 
  df_temerature %>% 
  filter(year %in% 2000:2020) %>% 
  group_by(state_abb, month) %>% 
  summarise(tempF = mean(tempF, na.rm = TRUE),
            .groups = "drop_last") %>% 
  rename(State = state_abb,
         Month = month)

# Prep 2: employment by industry and state
#   - Create the following variables
#     - emply_leisure: emply_accomm + emply_entertain
#     - emply_highSea5:   emply_construction + emply_retail + emply_gov + emply_leisure + emply mining
#     - emply_modestSea4: emply_highSea5 excluding construction
#   - Also create shares in total employment for the following vars
#     - emply_construction, emply_retail, emply_gov,  emply_leisure, emply mining
#     - emply_highSea5, emply_modestSea4,
#     - emply_farm
#
#   - Create a new data frame containing mean shares (across 2000-2020) of key variables 


df_emplyInd %<>% 
  mutate(emply_leisure    = emply_accomm + emply_entertain,
         emply_highSea5   = emply_construction + emply_retail + emply_gov + emply_leisure + emply_mining,
         emply_modestSea4 = emply_highSea5 - emply_construction,
         
         emplyShare_construction = emply_construction / emply_Tot,
         emplyShare_retail       = emply_retail/ emply_Tot,
         emplyShare_gov          = emply_gov/ emply_Tot,
         emplyShare_leisure      = emply_leisure/ emply_Tot, 
         emplyShare_mining       = emply_mining / emply_Tot,
         emplyShare_highSea5     = emply_highSea5/ emply_Tot, 
         emplyShare_modestSea4   = emply_modestSea4/ emply_Tot,
         emplyShare_farm         = emply_farm/ emply_Tot
         )

df_emplyInd_share <- 
  df_emplyInd %>% 
  filter(year %in% 2000:2020) %>% 
  group_by(State) %>% 
  summarise(across(starts_with("emplyShare"), ~ mean(.x, na.rm = TRUE)))

df_emplyInd_share

```


## Computing seasonal strength

```{r}

# Computing seasonal strength measures in two ways
#   1. Variance-based measure
#       - https://otexts.com/fpp3/stlfeatures.html
#       - max(0, Var(residual) / var(season + residual) )
#   2. SD of average seasonal factor (similar to Geremew & Gourio(2018))
#       - Calculate average seasonal factor across years (season)
#       - Standard deviation (w/ denominator n) of the average seasonal factors


# Note that these two seasonal strength measures serve different purposes
#   - The variance-based measure. It measures how the seasonal variation compares to 
#     the detrended variation. It demonstrates the relative importance of the seasonal 
#     varation in the overall detrended variation
#   - SD of seasonal factors. This measure does not involve any comparison with other 
#     component of the series. Rather, it measures the overall magnitude of the seasonal
#     component itself. 
#  
#   - This two measures may NOT be correlated. For example, a series may have a 
#     prominent seasonal pattern (high SD seasonal factor), but the seasonal variation 
#     may only accunt for a small proportion of the overall (detrended) variation due to 
#     a highly volatile residual (error) component. 

#   - For the paper
#      -  The first measure can be used to justify the importance of seasonality
#      -  The second one is more appropriate to use in the regression analysis. (as did in GG(2018))




pop.var <- function(x,...) var(x, ...) * (length(x)-1) / length(x)
pop.sd  <- function(x,...) sqrt(pop.var(x))


# 1 variace based measure

df_seaStr_var <- 
  ls_ets$df_comp_ets %>% 
  as_tibble %>% 
  filter(!is.na(remainder), !is.na(season)) %>% 
  group_by(State, .model) %>% 
  summarise(var_SR = pop.var(season + remainder, na.rm = TRUE),
            var_R  = pop.var(remainder, na.rm = TRUE)) %>% 
  mutate(seaStr_var = pmax(0, 1 - var_R/var_SR))
  


# 2 SD of average seasonal factor
df_seaStr_gg <- 
  ls_ets$df_comp_ets %>% 
  as_tibble %>% 
  filter(!is.na(remainder), !is.na(season)) %>% 
  mutate(month = month(date_yearmon)) %>% 
  group_by(State, .model, month) %>% 
  summarise(season_avg = mean(season, na.rm = TRUE), .groups = "drop_last") %>% 
  summarise(seaStr_gg  = pop.sd(season_avg), .groups = "drop")
  

# merging measures
df_seaStr <- 
  left_join(df_seaStr_var, df_seaStr_gg, by = c("State", ".model"))
  


# Check if the two measures are consistent 
df_seaStr %>% 
  group_by(.model) %>% 
  summarise(str_corr = cor(seaStr_var, seaStr_gg))












```











